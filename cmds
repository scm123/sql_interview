create trigger
before insert 
  on table_name
for each row


BEGIN

   -- variable declarations

   -- trigger code

END;

DECLARE 
   c_id customers.id%type; 
   c_name customers.name%type; 
   c_addr customers.address%type; 
   CURSOR c_customers is 
      SELECT id, name, address FROM customers; 
BEGIN 
   OPEN c_customers; 
   LOOP 
   FETCH c_customers into c_id, c_name, c_addr; 
      EXIT WHEN c_customers%notfound; 
      dbms_output.put_line(c_id || ' ' || c_name || ' ' || c_addr); 
   END LOOP; 
   CLOSE c_customers; 
END; 

Both the statements will remove the data from the "customers" table but the main difference is that you can roll back the DELETE statement whereas you can't roll back the TRUNCATE TABLE statement.


    CREATE TABLE new_table  
    AS (SELECT * FROM old_table);   

        CREATE TABLE newcustomers  
    AS (SELECT *   FROM customers  WHERE customer_id < 5000);  


        ALTER TABLE customers  
      ADD customer_age varchar2(50);  

      ALTER TABLE customers  
  ADD (customer_type varchar2(50),  
       customer_address varchar2(50)); 

           ALTER TABLE customers  
      MODIFY customer_name varchar2(100) not null;  
      
      
          INSERT ALL  
      INTO suppliers (supplier_id, supplier_name) VALUES (20, 'Google')  
      INTO suppliers (supplier_id, supplier_name) VALUES (21, 'Microsoft')  
      INTO suppliers (supplier_id, supplier_name) VALUES (22, 'Apple')  
    SELECT * FROM dual;  
    
    
        SELECT suppliers.supplier_id, suppliers.supplier_name, order1.order_number  
    FROM suppliers   
    INNER JOIN order1  
    ON suppliers.supplier_id = order1.supplier_id;  
    
    
    TableA                           TableB
+------------+----------+        +--------------------+    
|Column1     | Column2  |        |Column1  |  Column3 |
+-----------------------+        +--------------------+
| 1          |  2       |        | 1       |   3      |
+------------+----------+        +---------+----------+

The INNER JOIN of TableA and TableB on Column1 will return

SELECT * FROM TableA AS a INNER JOIN TableB AS b USING (Column1);
SELECT * FROM TableA AS a INNER JOIN TableB AS b ON a.Column1 = b.Column1;

+------------+-----------+---------------------+    
| a.Column1  | a.Column2 | b.Column1| b.Column3|
+------------------------+---------------------+
| 1          |  2        | 1        |   3      |
+------------+-----------+----------+----------+

The NATURAL JOIN of TableA and TableB on Column1 will return:

SELECT * FROM TableA NATURAL JOIN TableB
+------------+----------+----------+    
|Column1     | Column2  | Column3  |
+-----------------------+----------+
| 1          |  2       |   3      |
+------------+----------+----------+

The repeated column is avoided.


Equi Join

Equi join is a special type of join in which we use only an equality operator.
Hence, when you make a query for join using equality operator then that join query comes under Equi join.


      ALTER TABLE customers  
  DROP COLUMN customer_name;  

    ALTER TABLE customers  
     RENAME COLUMN customer_name to cname;  

         ALTER TABLE customers  
    RENAME TO retailers;  

    the main difference is that the temporary tables can't have foreign keys related to other tables.

    In Oracle, local temporary tables are distinct within modules. These tables are defined and scoped to the session in which you created it. 
    
    
    Natural Join

A natural join is a type of equi join which occurs implicitly by comparing all the same names columns in both tables. The join result has only one column for each pair of equally named columns.
Natural Join Example

--Run in Oracle and MySQL 
SELECT * FROM tblEmp NATURAL JOIN tblDept

A cursor is a temporary work area created in a system memory when an SQL statement is executed.

A database contains Logical Storage Unit called tablespaces. A tablespace is a set of related logical structures. Actually a tablespace groups related logical structures together.
